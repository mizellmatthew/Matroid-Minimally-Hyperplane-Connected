import sage.matroids.advanced

AG = matroids.AG(6,2) #Change the rank (the 6) to whatever you want.

# A matroid M is hyperplane connected if every hyperplane of M is connected. An example of such a matroid is the Fano plane (F7).
# Deleting a cocircuit of a matroid gives a hyperplane of the matroid
#This method will go through all hyperplanes of the matroids by checking the compliment of every cocircuit. 
#Then it will return False if it detects a disconnected hyperplane (i.e. the matroid is NOT hyperplane connected. 
def is_hyperplaneConnected(mat):
    #print(mat)
    for x in mat.cocircuits():
        test = mat.delete(x)
        #print(test)
        if test.is_connected() == False:
            return False
    return True
    
#A property we care about is being minimally hyperplane connected, that is, a matroid M is hyperplane connected and deleting any point of M
#will make M not hyperplane connected. Therefore we must go through every element of the matroid, delete it from M, then test to see if M-e
#is hyperplane connected. If we can find such an element where M-e is hyperplane connected, then M is not minimally hyperplane connected.
def is_minHPConnected(mat):
    for e in mat.groundset():
        delMat = mat.delete(e)
        if is_hyperplaneConnected(delMat) == True:
            return False
    return True
#From doing further research, we have found a more efficient way of creating hyperplane connected matroids
#Instead of deleting one element at a time, we delete specific full affine subspaces at a time. We have to get bases for this subspaces,
#So that is what the first part of this method is doing. At this time, I do not know of a way to grab specific flats without using a for loop,
(I HAVE TRIED VARIOUS METHODS AND THIS ONE IS THE ONLY ONE THAT WORKS). That is causing things to slow down at higher ranks. However we get solutions for
rank 8 and 9, which are usually computationally very difficult because of how big everything gets.
def reduceMatroid(mat):
    #Get a rank-(r-3) subset of AG(r-1,2)
    for x in mat.independent_sets_iterator(rank(mat) - 3):
        Z = x
        break
    #Make it a rank-(r-3) flat
    CLZ = mat.closure(Z) 

    #Get some element outside of the flat
    for e in mat.groundset().difference(CLZ):
        special_element = e
        break
        
    #Get a basis for a rank r-2 flat containing Z
    newList = [special_element]
    for e in Z:
        newList.append(e)
        
    #This is the flat containing Z
    ZrankR2Flat = mat.closure(newList)

    #Grab an element outside of this rank-(r-2) flat
    for e in mat.groundset().difference(ZrankR2Flat):
        newspecial = e
        break
    #This will be a basis for a rank-(r-2) flat Z2 whose closure will contain Z, but will be a different rank-(r-2) flat.
    newList2 = [newspecial]
    for e in Z:
        newList2.append(e)
    #This deletion will delete ZrankR2Flat and the closure of Z2. 
    BigDeletion = mat.delete(mat.closure(newList)).delete(mat.closure(newList2).difference(mat.closure(newList)))
    print(mat)
    print(BigDeletion)

    #Through experimentation, there is still more that can be deleted while staying hyperplane connected. We cannot delete any rank-(r-2) flats so we delete rank-(r-3) flats.
    for F in BigDeletion.flats(rank(mat) - 3):
        print(BigDeletion.delete(F))
        ourFlat = F
        break

    biggerDeletion = BigDeletion.delete(ourFlat)
    print(biggerDeletion)

    #We do this process again. 
    for F in biggerDeletion.flats(rank(mat) - 3): 
        if biggerDeletion.delete(F).rank() == biggerDeletion.rank():
            print(biggerDeletion.delete(F))
            ourFlat2 = F
            break
    #Our current belief is that this is the best possible bound. In total we delete 
    #2^{r-2} + (2^{r-2} - 2^{r-3}) + 2*2^{r-3} = 3*2^{r-2} - 2^{r-3} many elements from AG(r-1,2) which has a total of 2^{r-1} many elements.
    biggestDeletion = biggerDeletion.delete(ourFlat2)
    print(biggestDeletion)   
    print(is_hyperplaneConnected(biggestDeletion)) #True on rank 8!
    print(is_minHPConnected(biggestDeletion))
    print(biggestDeletion.representation())

reduceMatroid(AG)


